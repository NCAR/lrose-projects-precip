/**********************************************************************
 * TDRP params for NoiseMon
 **********************************************************************/

//======================================================================
//
// NoiseMon analyses data from time series files to estimate the noise 
//   power in each channel.
//
// Reading moments from CfRadial files is also an option.
//
//======================================================================
 
//======================================================================
//
// DEBUGGING AND PROCESS CONTROL.
//
//======================================================================
 
///////////// debug ///////////////////////////////////
//
// Debug option.
//
// If set, debug messages will be printed appropriately.
//
//
// Type: enum
// Options:
//     DEBUG_OFF
//     DEBUG_NORM
//     DEBUG_VERBOSE
//     DEBUG_EXTRA
//

debug = DEBUG_OFF;

///////////// instance ////////////////////////////////
//
// Process instance.
//
// Used for registration with procmap.
//
//
// Type: string
//

instance = "sband";

///////////// register_with_procmap ///////////////////
//
// Option to register with the process mapper.
//
// If true, this application will try to register with procmap once per 
//   minute. (If unable to do so, no error occurs.).
//
//
// Type: boolean
//

register_with_procmap = FALSE;

//======================================================================
//
// DATA INPUT.
//
//======================================================================
 
///////////// input_mode //////////////////////////////
//
// Input mode - files or time series API.
//
// RADX_MOMENTS_INPUT: read CfRadial files. DSR_MOMENTS_INPUT: read 
//   moments data from FMQ in DSR format. TS_FMQ_INPUT: read time series 
//   from a file message queue and process the pulses as they come in. 
//   TS_FILE_INPUT: read time series from files.
//
//
// Type: enum
// Options:
//     RADX_MOMENTS_INPUT
//     DSR_MOMENTS_INPUT
//     TS_FILE_INPUT
//     TS_FMQ_INPUT
//

input_mode = TS_FILE_INPUT;

//======================================================================
//
// REALTIME - DSR_MOMENTS_INPUT, TS_FMQ_INPUT.
//
//======================================================================
 
///////////// input_fmq_name //////////////////////////
//
// FMQ name. For DSR_MOMENTS_INPUT and TS_FMQ_INPUT.
//
// Path to FMQ files. There are 2 files, one with a .buf extension and 
//   one with a .stat extention. This path does not include the 
//   extensions.
//
//
// Type: string
//

input_fmq_name = "/tmp/fmq/ts";

///////////// seek_to_start_of_input //////////////////
//
// Option to seek to the start of the input FMQ.
//
// Applies to DSR_MOMENTS_INPUT and TS_FMQ_INPUT. If TRUE, the program 
//   will seek to the start of the fmq and read in data from the entire 
//   queue. If FALSE, it will only read new data as it is added to the 
//   FMQ.
//
//
// Type: boolean
//

seek_to_start_of_input = FALSE;

//======================================================================
//
// ARCHIVE - RADX_MOMENTS_INPUT, TS_FILE_INPUT.
//
//======================================================================
 
///////////// input_dir ///////////////////////////////
//
// Input directory for searching for files between start_time and 
//   end_time.
//
// RADX_MOMENTS_INPUT, TS_FILE_INPUT: files will be searched for in this 
//   directory. This is ignored if the list of files is  specified on the 
//   command line using the -f option.
//
//
// Type: string
//

input_dir = "$(DATA_DIR)/$(project)/time_series/sband/save";

///////////// start_time //////////////////////////////
//
// Set the start time for ARCHIVE mode analysis.
//
//  Applies to RADX_MOMENTS_INPUT and TS_FILE_INPUT. Format is 'yyyy mm 
//   dd hh mm ss'.
//
//
// Type: string
//

start_time = "2022 05 25 00 00 00";

///////////// end_time ////////////////////////////////
//
// Set the end time for ARCHIVE mode analysis.
//
//  Applies to RADX_MOMENTS_INPUT and TS_FILE_INPUT. Format is 'yyyy mm 
//   dd hh mm ss'.
//
//
// Type: string
//

end_time = "2022 08 11 03 00 00 00";

//======================================================================
//
// COMPUTING MOMENTS FROM TIME SERIES.
//
// TS_FILE_INPUT and TS_FMQ_INPUT modes.
//
//======================================================================
 
///////////// n_samples ///////////////////////////////
//
// Number of pulse samples in a beam.
//
//
// Type: int
//

n_samples = 128;

///////////// invert_hv_flag //////////////////////////
//
// Option to invert H/V flag in pulse data.
//
// Normally, the HV flag is set to 1 for H, 0 for V. If the flag in the 
//   data has the opposite sense, set this to true.
//
//
// Type: boolean
//

invert_hv_flag = FALSE;

///////////// cal_xml_file_path ///////////////////////
//
// Path for XML calibration file.
//
// At a minimum, the calibration file should contain noiseDbm, 
//   receiverGainDbm, dbz0 and radarConstant values for each channel.
//
//
// Type: string
//

cal_xml_file_path = "./sband_cal.xml";

///////////// xmit_rcv_mode ///////////////////////////
//
// Transmit/Receive mode for radar.
//
// Mode for xmit and receive for polarization diversity
// DP_ALT_HV_CO_ONLY: Dual pol, alternating transmission, copolar 
//   receiver only (e.g. CP2 S-band)
//  DP_ALT_HV_CO_CROSS: Dual pol, alternating transmission, co-polar and 
//   cross-polar receivers (e.g. SPOL with Mitch Switch and receiver in 
//   switching mode, CHILL)
//  DP_ALT_HV_FIXED_HV: Dual pol, alternating transmission, fixed H and 
//   V receivers (e.g. SPOL with Mitch Switch and receivers in fixed mode)
//  DP_SIM_HV_FIXED_HV: Dual pol, simultaneous transmission, fixed H and 
//   V receivers (e.g. NEXRAD upgrade, SPOL with T and receivers in fixed 
//   mode)
//  DP_SIM_HV_SWITCHED_HV: Dual pol, simultaneous transmission, 
//   switching H and V receivers (e.g. SPOL with T and receivers in 
//   switching mode).
//
//
// Type: enum
// Options:
//     DP_ALT_HV_CO_ONLY
//     DP_ALT_HV_CO_CROSS
//     DP_ALT_HV_FIXED_HV
//     DP_SIM_HV_FIXED_HV
//     DP_SIM_HV_SWITCHED_HV
//

xmit_rcv_mode = DP_SIM_HV_FIXED_HV;

//======================================================================
//
// READING MOMENTS FROM FMQ.
//
// DSR_MOMENTS_INPUT mode only.
//
//======================================================================
 
///////////// min_elevation ///////////////////////////
//
// Minimum elevation angle (deg).
//
// Beams below this elevation angle will be ignored.
//
//
// Type: double
//

min_elevation = 88;

///////////// input_fields ////////////////////////////
//
// List of input fields for moments.
//
// Applies to RADX_MOMENTS_INPUT and DSR_MOMENTS_INPUT.
//
//
// Type: struct
//   typedef struct {
//      moments_id_t id;
//        Options:
//          SNRHC
//          SNRVC
//          SNRHX
//          SNRVX
//          DBMHC
//          DBMVC
//          DBMHX
//          DBMVX
//          DBZ
//          VEL
//          WIDTH
//          PHIDP
//          RHOHV
//      string moments_name;
//   }
//
// 1D array - variable length.
//

input_fields = {
  {
    id = SNRHC,
    moments_name = "SNRHC"
  }
  ,
  {
    id = SNRVC,
    moments_name = "SNRVC"
  }
  ,
  {
    id = SNRHX,
    moments_name = "missing"
  }
  ,
  {
    id = SNRVX,
    moments_name = "missing"
  }
  ,
  {
    id = DBMHC,
    moments_name = "DBMHC"
  }
  ,
  {
    id = DBMVC,
    moments_name = "DBMVC"
  }
  ,
  {
    id = DBMHX,
    moments_name = "missing"
  }
  ,
  {
    id = DBMVX,
    moments_name = "missing"
  }
  ,
  {
    id = DBZ,
    moments_name = "DBZ"
  }
  ,
  {
    id = VEL,
    moments_name = "VEL"
  }
  ,
  {
    id = WIDTH,
    moments_name = "WIDTH"
  }
  ,
  {
    id = PHIDP,
    moments_name = "PHIDP"
  }
  ,
  {
    id = RHOHV,
    moments_name = "RHOHV"
  }
};

//======================================================================
//
// COMPUTING STATISTICS.
//
//======================================================================
 
///////////// stats_interval_secs /////////////////////
//
// Time interval for statistics (s).
//
// The statistics are computed at this interval, achored at the top of 
//   the hour. The interval should divide into 3600 without a remainder.
//
//
// Type: int
//

stats_interval_secs = 720;

///////////// min_elevation_deg ///////////////////////
//
// Minimum elevation angle for noise (deg).
//
// This should be high enough to clear all terrain, because terrain adds 
//   thermal noise to the returned signal.
//
//
// Type: double
//

min_elevation_deg = 6;

///////////// min_height_km ///////////////////////////
//
// Minimum height for noise (km).
//
// This should be above all likely weather echoes.
//
//
// Type: double
//

min_height_km = 40;

///////////// min_range_km ////////////////////////////
//
// Minimum range for estimating noise (km).
//
// This should be beyond any likely side-lobe echo from ground clutter.
//
//
// Type: double
//

min_range_km = 100;

///////////// max_range_km ////////////////////////////
//
// Maximum range for estimating noise (km).
//
// This is important if there is a test pulse in the data at long range. 
//   If so, set this just short of the test pulse range.
//
//
// Type: double
//

max_range_km = 220;

///////////// min_valid_count /////////////////////////
//
// Min number of valid points for stats.
//
// A valid point is a range gate that satisfies the thresholds below.
//
//
// Type: double
//

min_valid_count = 2000;

//======================================================================
//
// OUTPUT STATISTICS.
//
//======================================================================
 
///////////// write_stats_to_text_file ////////////////
//
// Option to write statistics to a text file.
//
// If true, stats for the entire run will be writted to a text file.
//
//
// Type: boolean
//

write_stats_to_text_file = TRUE;

///////////// text_output_dir /////////////////////////
//
// Dir for output text files.
//
// The results will be written to sub-directories named from the data 
//   time.
//
//
// Type: string
//

text_output_dir = "$(DATA_DIR)/$(project)/cal/noise_mon/sband/text";

///////////// write_stats_to_spdb /////////////////////
//
// Option to write out stats results to SPDB.
//
// The results will be written in XML, stored in SPDB. The data can then 
//   be retrieved for plotting or other purposes.
//
//
// Type: boolean
//

write_stats_to_spdb = TRUE;

///////////// spdb_output_url /////////////////////////
//
// URL for SPDB XML.
//
// For local writes, specify the directory. For remote writes, specify 
//   the full url: spdbp:://host::dir.
//
//
// Type: string
//

spdb_output_url = "$(DATA_DIR)/$(project)/cal/noise_mon/sband/spdb";

///////////// radar_name //////////////////////////////
//
// Radar name for tagging SPDB output data.
//
// This is used to set the data_type in SPDB.
//
//
// Type: string
//

radar_name = "SPOL";

