/**********************************************************************
 * TDRP params for NoiseMon
 **********************************************************************/

//======================================================================
//
// NoiseMon analyses data from time series files to estimate the noise 
//   power in each channel.
//
// Reading moments from CfRadial files is also an option.
//
//======================================================================
 
//======================================================================
//
// DEBUGGING AND PROCESS CONTROL.
//
//======================================================================
 
///////////// debug ///////////////////////////////////
//
// Debug option.
//
// If set, debug messages will be printed appropriately.
//
//
// Type: enum
// Options:
//     DEBUG_OFF
//     DEBUG_NORM
//     DEBUG_VERBOSE
//     DEBUG_EXTRA
//

debug = DEBUG_OFF;

///////////// instance ////////////////////////////////
//
// Process instance.
//
// Used for registration with procmap.
//
//
// Type: string
//

instance = "spoldrx";

///////////// register_with_procmap ///////////////////
//
// Option to register with the process mapper.
//
// If true, this application will try to register with procmap once per 
//   minute. (If unable to do so, no error occurs.).
//
//
// Type: boolean
//

register_with_procmap = FALSE;

//======================================================================
//
// DATA INPUT.
//
//======================================================================
 
///////////// input_mode //////////////////////////////
//
// Input mode - files or time series API.
//
// RADX_MOMENTS_INPUT: read CfRadial files. DSR_MOMENTS_INPUT: read 
//   moments data from FMQ in DSR format. TS_FMQ_INPUT: read time series 
//   from a file message queue and process the pulses as they come in. 
//   TS_FILE_INPUT: read time series from files.
//
//
// Type: enum
// Options:
//     RADX_MOMENTS_INPUT
//     DSR_MOMENTS_INPUT
//     TS_FILE_INPUT
//     TS_FMQ_INPUT
//

input_mode = TS_FILE_INPUT;

//======================================================================
//
// REALTIME - DSR_MOMENTS_INPUT, TS_FMQ_INPUT.
//
//======================================================================
 
///////////// input_fmq_name //////////////////////////
//
// FMQ name. For DSR_MOMENTS_INPUT and TS_FMQ_INPUT.
//
// Path to FMQ files. There are 2 files, one with a .buf extension and 
//   one with a .stat extention. This path does not include the 
//   extensions.
//
//
// Type: string
//

input_fmq_name = "/tmp/fmq/ts";

///////////// seek_to_start_of_input //////////////////
//
// Option to seek to the start of the input FMQ.
//
// Applies to DSR_MOMENTS_INPUT and TS_FMQ_INPUT. If TRUE, the program 
//   will seek to the start of the fmq and read in data from the entire 
//   queue. If FALSE, it will only read new data as it is added to the 
//   FMQ.
//
//
// Type: boolean
//

seek_to_start_of_input = FALSE;

//======================================================================
//
// ARCHIVE - RADX_MOMENTS_INPUT, TS_FILE_INPUT.
//
//======================================================================
 
///////////// input_dir ///////////////////////////////
//
// Input directory for searching for files between start_time and 
//   end_time.
//
// RADX_MOMENTS_INPUT, TS_FILE_INPUT: files will be searched for in this 
//   directory. This is ignored if the list of files is  specified on the 
//   command line using the -f option.
//
//
// Type: string
//

input_dir = "$(DATA_DIR)/$(project)/time_series/spoldrx/save";

///////////// start_time //////////////////////////////
//
// Set the start time for ARCHIVE mode analysis.
//
//  Applies to RADX_MOMENTS_INPUT and TS_FILE_INPUT. Format is 'yyyy mm 
//   dd hh mm ss'.
//
//
// Type: string
//

start_time = "2022 05 25 00 00 00";

///////////// end_time ////////////////////////////////
//
// Set the end time for ARCHIVE mode analysis.
//
//  Applies to RADX_MOMENTS_INPUT and TS_FILE_INPUT. Format is 'yyyy mm 
//   dd hh mm ss'.
//
//
// Type: string
//

end_time = "2022 08 11 03 00 00 00";

//======================================================================
//
// COMPUTING MOMENTS FROM TIME SERIES.
//
// TS_FILE_INPUT and TS_FMQ_INPUT modes.
//
//======================================================================
 
///////////// n_samples ///////////////////////////////
//
// Number of pulse samples in a beam.
//
//
// Type: int
//

n_samples = 128;

///////////// invert_hv_flag //////////////////////////
//
// Option to invert H/V flag in pulse data.
//
// Normally, the HV flag is set to 1 for H, 0 for V. If the flag in the 
//   data has the opposite sense, set this to true.
//
//
// Type: boolean
//

invert_hv_flag = FALSE;

///////////// cal_xml_file_path ///////////////////////
//
// Path for XML calibration file.
//
// At a minimum, the calibration file should contain noiseDbm, 
//   receiverGainDbm, dbz0 and radarConstant values for each channel.
//
//
// Type: string
//

cal_xml_file_path = "$(PROJ_DIR)/qc/params/spoldrx_cal_1.5.xml";

//======================================================================
//
// READING MOMENTS FROM FMQ.
//
// DSR_MOMENTS_INPUT mode only.
//
//======================================================================
 
///////////// min_elevation ///////////////////////////
//
// Minimum elevation angle (deg).
//
// Beams below this elevation angle will be ignored.
//
//
// Type: double
//

min_elevation = 88;

///////////// input_fields ////////////////////////////
//
// Lookup table for field names in moments.
//
// Applies to RADX_MOMENTS_INPUT and DSR_MOMENTS_INPUT.
//
//
// Type: struct
//   typedef struct {
//      moments_id_t id;
//        Options:
//          DBMHC
//          DBMVC
//          DBMHX
//          DBMVX
//          DBZ
//      string moments_name;
//   }
//
// 1D array - variable length.
//

input_fields = {
  {
    id = DBMHC,
    moments_name = "DBMHC"
  }
  ,
  {
    id = DBMVC,
    moments_name = "DBMVC"
  }
  ,
  {
    id = DBMHX,
    moments_name = "missing"
  }
  ,
  {
    id = DBMVX,
    moments_name = "missing"
  }
  ,
  {
    id = DBZ,
    moments_name = "DBZ"
  }
};

//======================================================================
//
// AVOIDING THE SUN.
//
// We want to avoid rays with angles close to the sun, since these will 
//   have elevated white noise.
//
//======================================================================
 
///////////// avoid_the_sun ///////////////////////////
//
// Option to avoid rays close to the sun.
//
// If true we will not include angles within 
//   'sun_avoidance_angle_margin_deg' of the sun.
//
//
// Type: boolean
//

avoid_the_sun = TRUE;

///////////// sun_avoidance_angle_margin_deg //////////
//
// Angular margin for avoiding the sun (deg).
//
// We only consider rays that are outside this margin relative to the 
//   sun.
//
//
// Type: double
//

sun_avoidance_angle_margin_deg = 3;

//======================================================================
//
// AVOIDING STRONG ECHO.
//
// We want to avoid rays with strong echo, since this raises the noise 
//   floor with thermal emissions.
//
//======================================================================
 
///////////// avoid_strong_echo ///////////////////////
//
// Option to avoid rays with strong echo.
//
// If true we will not include rays with strong echo.
//
//
// Type: boolean
//

avoid_strong_echo = TRUE;

///////////// strong_echo_dbz_threshold ///////////////
//
// Threshold for considering echo at a gate as strong (dBZ).
//
// In computing the strong echo sum, we only include gates with 
//   reflectivity in excess of this threshold.
//
//
// Type: double
//

strong_echo_dbz_threshold = 35;

///////////// strong_echo_dbz_sum_max /////////////////
//
// Upper limit of reflectivity sum (dBZ).
//
// We add up the reflectivity at all gates with values in excess of 
//   'strong_echo_dbz_threshold'. If the sum exceeds this max, we discard 
//   the ray.
//
//
// Type: double
//

strong_echo_dbz_sum_max = 250;

//======================================================================
//
// COMPUTING STATISTICS.
//
//======================================================================
 
///////////// stats_interval_secs /////////////////////
//
// Time interval for statistics (s).
//
// The statistics are computed at this interval, achored at the top of 
//   the hour. The interval should divide into 3600 without a remainder.
//
//
// Type: int
//

stats_interval_secs = 720;

///////////// min_elevation_deg ///////////////////////
//
// Minimum elevation angle for noise (deg).
//
// This should be high enough to clear all terrain, because terrain adds 
//   thermal noise to the returned signal.
//
//
// Type: double
//

min_elevation_deg = 6;

///////////// min_height_km ///////////////////////////
//
// Minimum height for noise (km).
//
// This should be above all likely weather echoes.
//
//
// Type: double
//

min_height_km = 40;

///////////// min_range_km ////////////////////////////
//
// Minimum range for estimating noise (km).
//
// This should be beyond any likely side-lobe echo from ground clutter.
//
//
// Type: double
//

min_range_km = 100;

///////////// max_range_km ////////////////////////////
//
// Maximum range for estimating noise (km).
//
// This is important if there is a test pulse in the data at long range. 
//   If so, set this just short of the test pulse range.
//
//
// Type: double
//

max_range_km = 220;

///////////// min_valid_count /////////////////////////
//
// Min number of valid points for stats.
//
// A valid point is a range gate that satisfies the thresholds below.
//
//
// Type: double
//

min_valid_count = 2000;

///////////// max_valid_noise_power_dbm ///////////////
//
// Maximum valid noise power (dBm).
//
// If either H or V noise power exceeds this, the point is discarded.
//
//
// Type: double
//

max_valid_noise_power_dbm = -70;

//======================================================================
//
// OUTPUT STATISTICS.
//
//======================================================================
 
///////////// write_stats_to_text_file ////////////////
//
// Option to write statistics to a text file.
//
// If true, stats for the entire run will be writted to a text file.
//
//
// Type: boolean
//

write_stats_to_text_file = TRUE;

///////////// text_output_dir /////////////////////////
//
// Dir for output text files.
//
// The results will be written to sub-directories named from the data 
//   time.
//
//
// Type: string
//

text_output_dir = "$(DATA_DIR)/$(project)/calibration/spol/noise_mon/spoldrx/text";

///////////// write_stats_to_spdb /////////////////////
//
// Option to write out stats results to SPDB.
//
// The results will be written in XML, stored in SPDB. The data can then 
//   be retrieved for plotting or other purposes.
//
//
// Type: boolean
//

write_stats_to_spdb = TRUE;

///////////// spdb_output_url /////////////////////////
//
// URL for SPDB XML.
//
// For local writes, specify the directory. For remote writes, specify 
//   the full url: spdbp:://host::dir.
//
//
// Type: string
//

spdb_output_url = "$(DATA_DIR)/$(project)/calibration/spol/noise_mon/spoldrx/spdb";

///////////// radar_name //////////////////////////////
//
// Radar name for tagging SPDB output data.
//
// This is used to set the data_type in SPDB.
//
//
// Type: string
//

radar_name = "SPOL";

